Tìm hiểu về interconnection trong hệ thống SoC (Hay nói đúng hơn là bus)
1.	GIỚI THIỆU
Các thiết kế SOC thường liên quan đến việc tích hợp các lõi IP lại với nhau thành một hệ thống, mỗi lõi được thiết kế và verified riêng biệt. Các nhà tích hợp hệ thống có thể tối đa hóa việc tái sử dụng thiết kế để giảm chi phí và giảm rủi ro. Thường thì vấn đề quan trọng nhất là phương thức mà các lõi IP được kết nối với nhau.
Bài viết này sẽ cung cấp một cái nhìn tổng quan về 2 kiến trúc được sử dụng phổ biến trong một hệ thống SOC: bus và network-on-chip (NOC). 
Kiến trúc bus được phát triển cụ thể cho các thiết kế SOC được mô tả và so sánh. Tuy nhiên, đối với 1 hệ thống SoC có rất nhiều IP thì người ta sẽ ưu tiên sử dụng kiến trúc NOC


Như trong hình trên ta có thể thấy hai loại interconnection chính đó là:
Internal interconnection: Connect các IP trong hệ thống SoC.
External interconnection: Connect giữa Chip SoC và các IP bên ngoài như ASIC hay DRAM.



. Một NOC thường bao gồm một mức độ trừu tượng của giao diện, ẩn các kết nối vật lý cơ bản khỏi nhà thiết kế. Chúng tôi theo dõi việc sử dụng SOC hiện tại và đề cập đến kết nối như một chiếc xe buýt hoặc như một NOC được thực hiện bởi một công tắc. Trong NOC, công tắc có thể là một thanh ngang, kết nối được liên kết trực tiếp hoặc mạng chuyển mạch đa tầng. T ở đây là rất nhiều tài liệu kết nối xe buýt và máy tính. Các đơn vị được kết nối đôi khi được gọi là các tác nhân (trong xe buýt) hoặc các nút (trong tài liệu kết nối chung); chúng tôi chỉ đơn giản là sử dụng các đơn vị hạn. Do các kết nối SOC hiện tại thường liên quan đến một số lượng đơn vị khiêm tốn, nên chương này cung cấp một cái nhìn đơn giản về các lựa chọn thay thế kết nối. Một điều trị toàn diện về kiến trúc truyền thông trên chip có sẵn ở nơi khác [193]. Để thảo luận chung về các mạng kết nối máy tính, hãy xem bất kỳ văn bản tiêu chuẩn nào
2.	Tổng quan về kiến trúc của interconnection
Hình bên dưới mô tả một hệ thống gồm một mô-đun SOC. Mô-đun SOC thường chứa một số khối IP, một hoặc nhiều trong số đó là bộ vi xử lý. Ngoài ra, có nhiều loại bộ nhớ trên chip như bộ nhớ cache, bộ nhớ lưu trữ dữ liệu hoặc bộ nhớ lưu trữ tập lệnh. Các khối IP khác nhau phục vụ cho các ứng dụng và các chức năng cụ thể, chẳng hạn như bộ xử lý đồ họa,  video decode hoặc bộ điều khiển mạng, được tích hợp trong SOC.
     Hình 5.1 Sơ đồ khối đơn giản của mô-đun SOC trong ngữ cảnh hệ thống.

Các khối IP trong mô-đun SOC cần liên lạc với nhau. Chúng thực hiện điều này thông qua các kết nối, được truy cập thông qua một đơn vị giao diện kết nối (ICU). ICU cho phép một giao thức giao diện chung cho tất cả các mô-đun SOC. Bên ngoài mô-đun SOC là các bộ nhớ ngoài, các thiết bị ngoại vi và các thiết bị lưu trữ dung lượng lớn. Do đó, chi phí và hiệu suất của hệ thống phụ thuộc vào cả cấu trúc kết nối trên chip và ngoài chip. Chọn một kiến trúc kết nối phù hợp đòi hỏi sự hiểu biết về một số vấn đề ở cấp hệ thống và các thông số kỹ thuật. Bên dưới là một số thông số kĩ thuật:
   1. Băng thông truyền: Tốc độ truyền thông tin giữa một mô-đun và môi trường xung quanh mà nó hoạt động. Thường được đo bằng số byte được transfer trên mỗi đơn vị thời gian(giây).
Yêu cầu băng thông của mô-đun chỉ ra ở mức độ lớn loại kết nối được yêu cầu để đạt được thông số kỹ thuật thông lượng chung của hệ thống.
2. Độ trễ truyền thông: là thời gian trễ của  mô-đun khi bắt đầu gửi dữ liệu cho đến khi nhận được phản hồi từ module nhận. Độ trễ có thể quan trọng hoặc không đối với hiệu suất của hệ thống tổng thể. Ví dụ, độ trễ lớn trong ứng dụng truyền phát video thường ít hoặc không ảnh hưởng đến trải nghiệm của người dùng. Xem một bộ phim muộn hơn vài giây so với khi nó thực sự được phát sóng là không ảnh hưởng nhiều. Ngược lại, ngay cả những độ trễ nhỏ, không lường trước được trong giao thức di động hai chiều có thể khiến cho việc thực hiện một cuộc trò chuyện gần như không thể thực hiện được. Ví dụ: A nói với B. Sau 3s sau B nhận được và B phản hồi A. Hoặc vấn đề xử lí ảnh , nhận dạng hình ảnh trong các chip ô tô tự lái. Nếu việc xử lí nhận dạng có độ trễ lớn, Xe không thể xử lí kịp tình huống và tai nạn có thể xảy ra. 

3.	Master và slave: Những điều khoản này liên quan đến khả năng một master có thể bắt đầu khởi tạo các request hoặc các slave có thể response lại khi nhận được 1 request từ master. Một master, chẳng hạn như bộ vi xử lý, kiểm soát các giao dịch giữa chính nó và các mô-đun khác. Một slave, chẳng hạn như bộ nhớ, đáp ứng các yêu cầu từ master gửi xuống. Một thiết kế SOC thường có một số master và nhiều slave.
4. Yêu cầu đồng thời. Số lượng các kênh truyền (hay nói đúng hơn là nhiều master cùng có thể gửi đi request tại cùng 1 thời điểm) độc lập hoạt động song song đồng thời. Thông thường, các kênh bổ sung cải thiện băng thông hệ thống. 
5.Package or bus transaction. Size dữ liệu và định nghĩa thông tin được truyền trong một giao dịch. Đối với kiểu bus, địa chỉ này bao gồm một địa chỉ với các bit điều khiển (đọc / ghi, v.v.) và dữ liệu. Trong NOC điều này được gọi là một gói. Gói bao gồm một tiêu đề (địa chỉ và tín hiệu điều khiển) và dữ liệu. 
6. ICU. Trong một kết nối, đơn vị này quản lý giao thức kết nối và giao dịch vật lý. Nó có thể đơn giản hoặc phức tạp, bao gồm cả bộ đệm và quản lý giao dịch bên ngoài. Nếu lõi IP yêu cầu chuyển đổi giao thức để truy cập vào bus, đơn vị này được gọi là bus wrapper. Trong NOC, đơn vị này quản lý giao thức vận chuyển gói từ lõi IP sang mạng chuyển mạch. Nó cung cấp bộ đệm gói và truyền giao dịch ra bên ngoài. 
7. Nhiều miền clock. Các mô-đun IP khác nhau có thể hoạt động ở các tần số clock khác nhau và tập dữ liệu khác nhau. Ví dụ, một máy quay video ghi lại dữ liệu pixel ở tốc độ được điều chỉnh bởi tiêu chuẩn video được sử dụng, trong khi tốc độ xung nhịp của bộ xử lý thường được xác định bởi công nghệ và thiết kế kiến trúc. Do đó, các khối IP bên trong SOC thường cần hoạt động ở các tần số xung nhịp khác nhau, tạo ra các vùng tần số riêng biệt được gọi là miền clock. Giao thoa giữa các miền clock có thể gây ra sự cố bế tắc và bất đồng bộ nếu không thiết kế cẩn thận.

 Bằng cách đưa ra một tập hợp các thông số kỹ thuật, một nhà thiết kế có thể tìm thấy các yêu cầu khác nhau về băng thông, độ trễ, tính đồng thời và miền clock của các kiến trúc kết nối khác nhau, như bus và NOC. Một số ví dụ trong số này được đưa ra trong Bảng 5.1. Các ví dụ khác bao gồm Avalon Bus cho Altera eld - mảng cổng có thể lập trình (FPGA) [10], Kết nối Wishbone để sử dụng trong các lõi và nền tảng nguồn mở [189] và giao thức AXI4- Stream để thực hiện FPGA [74] . Thiết kế kiến trúc kết nối cho SOC đòi hỏi phải xem xét cẩn thận nhiều yêu cầu, chẳng hạn như các yêu cầu được liệt kê ở trên. Phần còn lại của chương này giới thiệu về hai kiến trúc kết nối: xe buýt và NOC.


Bus: KIẾN TRÚC CƠ BẢN
Hiệu năng của một hệ thống máy tính phụ thuộc rất nhiều vào đặc điểm của kiến trúc kết nối giữa các thành phần bên trong nó. Một hệ thống bus được xem xét như là một thiết kế có thể điều tiết việc truyền các tập lệnh và dữ liệu giữa bộ nhớ và bộ xử lý, hoặc giữa các thiết bị ngoại vi và bộ nhớ. Nút thắt truyền thông này là tâm điểm chú ý của nhiều nhà sản xuất hệ thống và vi xử lý, trong ba thập kỷ qua, đã áp dụng một số tiêu chuẩn bus khác nhau. Chúng bao gồm bus VME phổ biến và Intel Multibus - II. Đối với các hệ thống trên bo mạch và máy tính cá nhân, quá trình tiến hóa bao gồm bus kiến trúc tập lệnh (ISA), bus EISA và các bus PCI và PCI Express hiện đang thịnh hành. Tất cả các tiêu chuẩn bus này được thiết kế để kết nối các mạch tích hợp (IC) với nhau trên bảng mạch in (PCB) hoặc PCB trong quá trình thực hiện trên hệ thống. Mặc dù các tiêu chuẩn bus này đã phục vụ cộng đồng điện toán tốt, nhưng chúng không đặc biệt phù hợp với công nghệ SOC. Ví dụ, tất cả các xe buýt cấp hệ thống như vậy được thiết kế để lái một bảng nối đa năng, trong hệ thống gắn trên giá hoặc trên bo mạch chủ máy tính. Điều này áp đặt nhiều hạn chế trên kiến trúc xe buýt. Để bắt đầu, số lượng tín hiệu khả dụng thường bị hạn chế bởi số lượng pin giới hạn trên gói IC hoặc số chân trên đầu nối PCB. Thêm một pin phụ trên một gói hoặc một kết nối là tốn kém. Hơn nữa, tốc độ mà xe buýt có thể hoạt động thường bị giới hạn bởi tải điện dung cao trên mỗi tín hiệu xe buýt, điện trở của các tiếp điểm trên đầu nối và nhiễu điện từ được tạo ra bởi các tín hiệu chuyển mạch nhanh như vậy truyền xuống đường ray PCB. Cuối cùng, trình điều khiển cho xe buýt trên chip có thể nhỏ hơn nhiều, tiết kiệm diện tích và năng lượng. Trước khi mô tả chi tiết hoạt động của xe buýt và cấu trúc xe buýt, chúng tôi cung cấp, trong Bảng 5.2, so sánh hai kiến trúc kết nối xe buýt khác nhau, cho thấy ước tính kích thước và tốc độ cho một nô lệ xe buýt điển hình.
5.3.1 Trọng tài và giao thức C về mặt tình cờ, xe buýt chỉ là dây được chia sẻ bởi nhiều đơn vị. Trong thực tế, một số logic phải có mặt để cung cấp việc sử dụng xe buýt có trật tự; mặt khác, hai đơn vị có thể gửi tín hiệu cùng một lúc, gây ra các tín hiệu. Khi một đơn vị sử dụng độc quyền xe buýt, đơn vị được cho là sở hữu xe buýt. Các đơn vị có thể là các đơn vị chủ có khả năng có thể yêu cầu quyền sở hữu hoặc các đơn vị nô lệ thụ động và chỉ đáp ứng các yêu cầu. Bus master là đơn vị bắt đầu giao tiếp trên bus máy tính hoặc đường dẫn đầu vào / đầu ra (I / O). Trong SOC, bus master là một thành phần trong chip, chẳng hạn như bộ xử lý. Các đơn vị khác được kết nối với một bus trên chip, chẳng hạn như các thiết bị I / O và các thành phần bộ nhớ, là các nô lệ. Người chủ xe buýt điều khiển các tuyến xe buýt bằng cách sử dụng các địa chỉ nô lệ cụ thể và tín hiệu điều khiển. Hơn nữa, chủ xe buýt cũng kiểm soát ﬂ ow tín hiệu dữ liệu trực tiếp giữa chủ và nô lệ.
  BẢNG 5.2 So sánh các kiến trúc kết nối xe buýt [198] Vùng tốc độ tiêu chuẩn (MHz) (rbe *) AMBA (phụ thuộc triển khai) 166 - 400 175.000 CoreConnect 66/133/183 160.000 * rbe = r egister bit tương đương; ước tính là gần đúng và thay đổi theo việc thực hiện.
c05.indd 170 c05.indd 170 5/4/2011 9:54:27 sáng 5/4/2011 9:54:27 sáng
Arbitrate.
 Arbitrate (Hay còn gọi là bộ trọng tài, bộ phân xử). Tất cả các transaction đi qua bus đến 1 slave nhất định (Điều này nghĩa là có nhiều đường data từ các master khác nhau access đến 1 slave cố định) bộ arbitrate sẽ được đặt trước các slave này.  Sau đó, bộ phân xử này sẽ cấp quyền xem liệu đường dữ liệu nào được gửi đi qua bus. Giao thức bus là một bộ quy tắc thống nhất để truyền thông tin giữa hai hoặc nhiều thiết bị qua hệ thống bus. Giao thức xác định như sau:
• Loại và thứ tự của dữ liệu được gửi; 
• Cách master thông báo nó đã hoàn tất việc gửi thông tin; 
• Phương pháp nén dữ liệu được sử dụng, nếu có; 
• Cách  slave thông báo rằng nó đã nhận thông tin thành công; 
 • Cách khối phân xử thực hiện để giải quyết các tranh chấp trên bus, ưu tiên và loại kiểm tra lỗi sẽ được sử dụng (Hay còn gọi là fusa function).


Cầu 

Cầu bus là một mô-đun nhằm kết nối hai bus lại với nhau, không nhất thiết phải cùng loại. Một cầu điển hình có thể phục vụ ba chức năng:
1. Nếu hai bus sử dụng các giao thức khác nhau (ví dụ AXI và APB), một cầu nối bus cung cấp các định dạng cần thiết và chuyển đổi các giao thức đó. 
2. Một cầu được chèn vào giữa hai bus để phân đoạn chúng và giữ cho các bus được chứa trong các phân đoạn. Điều này cải thiện sự tương tranh: cả hai xe buýt có thể hoạt động cùng một lúc.
 3. Một cầu thường chứa bộ đệm và các mạch điều khiển liên quan cho phép lưu trữ các transaction. Khi một master bắt đầu chuyển dữ liệu sang slave trên một bus qua cầu, dữ liệu sẽ được lưu tạm thời trong bộ đệm, cho phép master tiến hành các giao dịch tiếp theo trước khi dữ liệu thực sự được ghi vào slave. Bằng cách cho phép các giao dịch hoàn thành nhanh chóng, một cầu bus có thể cải thiện đáng kể hiệu năng hệ thống.



   5.3.3 Cấu trúc xe buýt vật lý Bản chất của giao dịch xe buýt phụ thuộc vào cấu trúc xe buýt vật lý (số đường dẫn dây, thời gian chu kỳ, v.v.) và giao thức (đặc biệt là hỗ trợ trọng tài). Nhiều người dùng xe buýt phải được phân xử để truy cập vào xe buýt trong bất kỳ chu kỳ nhất định. Vì vậy, trọng tài là một phần của giao dịch xe buýt. Các trọng tài đơn giản có một chu kỳ yêu cầu trong đó các tín hiệu từ người dùng được ưu tiên, theo sau là chu trình xác nhận chọn người dùng. Các trọng tài phức tạp hơn thêm các dòng điều khiển xe buýt và logic liên quan để mỗi người dùng nhận thức được trạng thái và mức độ ưu tiên của xe buýt đang chờ xử lý. Trong các thiết kế như vậy, không có chu kỳ nào được thêm vào giao dịch xe buýt để phân xử.
   Các loại xe buýt Xe buýt có thể được thay đổi hoặc phân chia (địa chỉ và dữ liệu). Trong xe buýt đơn, địa chỉ ban đầu được truyền trong một chu kỳ xe buýt theo sau là một hoặc nhiều chu kỳ dữ liệu; xe buýt phân chia có xe buýt riêng cho từng chức năng này. Ngoài ra, các xe buýt có thể là giao dịch đơn lẻ hoặc thuê. Xe buýt thuê được chiếm dụng bởi một giao dịch chỉ trong các địa chỉ liên quan hoặc chu kỳ dữ liệu. Những chiếc xe buýt như vậy có bộ thu đơn vị đệm các tin nhắn và tạo các giao dịch dữ liệu và địa chỉ riêng biệt.



VÍ DỤ về bus Có nhiều thiết kế bus với sự kết hợp khác nhau giữa của nhiều loại bit width và các giao thức trọng tài. Các ví dụ dưới đây xem xét một số khả năng rõ ràng. Giả sử bus có độ trễ đường truyền là một chu kỳ và bộ nhớ (hoặc bộ đệm chung) có độ trễ truy cập bốn chu kỳ sau khi địa chỉ đầu được khởi tạo và đồng thời yêu cầu một chu kỳ bổ sung cho mỗi lần truy cập dữ liệu tuần tự. Bộ nhớ được truy cập 4 byte mỗi lần. Dữ liệu được truyền đi bao gồm một dòng bộ đệm 16 byte. Yêu cầu địa chỉ là 4 byte. Trong các ví dụ này, truy cập T là thời gian cần thiết để truy cập từ đầu tiên từ bộ nhớ sau khi địa chỉ được cấp và truy cập dòng là thời gian cần thiết để truy cập các từ còn lại. Ngoài ra, byte dữ liệu cuối cùng đến vào cuối mẫu thời gian và chỉ có thể được sử dụng sau thời điểm đó.

    (a) Xe buýt đơn giản. Đây là một xe buýt giao dịch duy nhất với trọng tài yêu cầu / xác nhận (ack) đơn giản. Nó có chiều rộng vật lý là 4 byte. Các tín hiệu yêu cầu và tín hiệu ack là các tín hiệu riêng biệt nhưng được coi là một phần của giao dịch xe buýt, vì vậy độ trễ giao dịch xe buýt là 11 chu kỳ. Từ đầu tiên được gửi từ bộ nhớ ở chu kỳ truy cập T cuối cùng, trong khi từ thứ tư (và cuối cùng) được gửi từ bộ nhớ ở chu kỳ truy cập cuối cùng. Chu kỳ xe buýt cuối cùng là để thiết lập lại trọng tài.

(b) Xe buýt có Hỗ trợ Trọng tài. Bus này có trọng tài phức tạp hơn nhưng vẫn có chiều rộng vật lý 4 byte và tích hợp địa chỉ và dữ liệu. Có một chu kỳ truy cập bổ sung (chu kỳ thay vì bốn) để biểu thị thời gian để chuyển địa chỉ từ bộ thu bus sang bộ nhớ. Điều này không được hiển thị trong trường hợp (a), vì các xe buýt đơn giản thường chậm hơn với khớp nối ngay lập tức với bộ nhớ. Bây giờ các chu kỳ ban đầu cho yêu cầu và ack bị chồng chéo với quá trình xử lý xe buýt và chu trình cuối cùng để đặt lại trọng tài không được hiển thị trong trường hợp cho trường hợp (b), vì vậy giao dịch xe buýt hiện mất 10 chu kỳ.
   (c) Bus chia tách có độ dài, rộng 4 byte. Giả định là dòng được yêu cầu được nạp vào bộ đệm cho các chu kỳ và sau đó được truyền theo bốn chu kỳ. Mặc dù độ trễ giao dịch, bao gồm cả chu kỳ cho địa chỉ, không khác với trường hợp (b) ở 10 chu kỳ, giao dịch chiếm xe buýt dưới một nửa (bốn chu kỳ) thời gian đó. Bus địa chỉ chỉ được sử dụng cho một chu kỳ trong số 10. Thời gian còn lại dành cho các giao dịch không liên quan khác để cải thiện hiệu suất liên lạc.
 (d) Bus chia tách có thời hạn, rộng 16 byte, với thời gian giao dịch xe buýt một chu kỳ. Một s với trường hợp (c), độ trễ giao dịch không bị ảnh hưởng ở 10 chu kỳ. Do bộ nhớ giới hạn rõ ràng hệ thống, nên trong trường hợp này, bộ nhớ sẽ tìm nạp toàn bộ dòng bộ đệm 16 byte trước khi truyền nó trong một chu kỳ. Cả hai bus địa chỉ và dữ liệu chỉ được sử dụng cho một chu kỳ cho mỗi giao dịch. Lưu ý rằng ure gure cho trường hợp (d) cho phép một chu kỳ bổ sung để xử lý lại xe buýt, mặc dù điều này có thể không cần thiết và không được tính trong trường hợp (c)
 Các trường hợp (c) và (d) rất thú vị, vì băng thông bus vượt quá băng thông bộ nhớ; ví dụ, trong trường hợp (d), bộ nhớ bận trong bảy chu kỳ (bốn chu kỳ để truy cập từ đầu tiên và ba chu kỳ để đánh giá các từ còn lại) nhưng xe buýt chỉ bận trong một chu kỳ. Trong cả hai trường hợp này, tình huống bộ nhớ bus bus - tình trạng bộ nhớ bị giới hạn bộ nhớ vì đó là nơi tranh chấp sẽ phát triển.




5.4 XE BUÝT TIÊU CHUẨN
Có 2 loại chuẩn giao tiếp thường được sử dụng  trong 1 hệ thống SOC đó là chuẩn AMBA do ARM phát triển và chuẩn CoreConnect do IBM phát triển. Chuẩn CoreConnect đã được sử dụng trong đồ các đồ họa nền tảng Virtex của Xilinx.
Chuẩn AMBA
Chuẩn AMBA được giới thiệu vào năm 1997, có nguồn gốc từ bộ xử lý ARM, đây là một trong những bộ xử lý SOC thành công nhất được sử dụng trong ngành. Xe buýt AMBA dựa trên kiến trúc xe buýt truyền thống sử dụng hai cấp độ phân cấp. Hai xe buýt được định nghĩa trong thông số kỹ thuật AMBA [22]:
    • Bus hiệu suất cao (AHB) được thiết kế để kết nối các bộ xử lý nhúng, như lõi bộ xử lý ARM, với các thiết bị ngoại vi đòi hỏi performance cao, điều khiển truy cập bộ nhớ trực tiếp (DMA), bộ nhớ trên chip và interface. AHB là một kiến trúc bus tốc độ cao, băng thông cao, sử dụng một địa chỉ riêng, đọc và ghi. Bit width tối thiểu của chuẩn AHB là 32 bit dữ liệu và có thể mở rộng thành 1024 bit. Chuẩn AHB còn hỗ trợ việc hoạt động đồng thời của nhiều master/slave. Nó cũng hỗ trợ việc gửi dữ liệu theo gói (burst) và phân chia data để gửi. Tất cả các transaction trong bus AHB hoạt động với một cạnh clock nhất định (Có thể là cạnh lên hoặc xuống tuỳ nhà thiết kế định nghĩa)  điều này giúp thiết kế cấp hệ thống trở nên dễ hiểu.

• Chuẩn giao tiếp APB có hiệu suất thấp hơn bus AHB, nhưng được tối ưu hóa để tiêu thụ năng lượng tối thiểu và giảm độ phức tạp của các transaction. Nó được thiết kế để giao tiếp với các mô-đun ngoại vi không đòi hỏi tốc độ cao.

Chuẩn giao tiếp ASB là phiên bản trước của AHB, được thiết kế cho các hệ thống hiệu suất thấp sử dụng bộ vi điều khiển 16/32-bit. Nó được sử dụng khi chi phí, hiệu suất và độ phức tạp của AHB không thể đáp ứng được yêu cầu thiết kế. 
Chuẩn giao tiếp AMBA được thiết kế để giải quyết một số vấn đề được đưa ra bởi những người sử dụng bus với vi xử lý ARM được tích hợp trong SOC. Các mục tiêu đạt được theo thiết kế của nó là :
   1. Thiết kế mô đun và tái sử dụng thiết kế. Do giao diện bus bộ xử lý ARM cực kỳ linh hoạt, các nhà thiết kế thiếu kinh nghiệm có thể vô tình tạo ra các thiết kế không hiệu quả hoặc thậm chí không thể thực hiện được bằng cách sử dụng logic ad hoc và logic điều khiển. Đặc tả AMBA khuyến khích một phương pháp thiết kế mô-đun hỗ trợ phân vùng thiết kế tốt hơn và tái sử dụng thiết kế. 
 2. Giao thức transfer định nghĩa rõ ràng, clock và reset. AMBA có giao diện và hoạt động theo nguyên lí clock đơn giản và linh hoạt. Hiệu suất của bus AMBA được tăng cường nhờ việc nhiều master có thể gửi request đồng thời, Các transaction có thể được phân chia nhỏ để gửi hoặc gộp vào các busrt để gửi. 
3. Hỗ trợ năng lượng thấp: Một trong những điểm hấp dẫn của vi xử lý ARM khi so sánh với các dòng vi xử lý khác là nằm ở việc sử dụng năng lượng hiệu quả. Việc phân vùng hai cấp của các bus AMBA đảm bảo năng lượng - thiết kế hiệu quả trong các mô-đun ngoại vi, phù hợp với lõi CPU công suất thấp.



  Hình 5.2 mô tả một hệ thống điển hình sử dụng kiến trúc bus AMBA. AHB tạo thành bus xương sống của hệ thống trong đó ta có vi xử lý ARM, giao diện bộ nhớ băng thông cao và bộ nhớ truy cập ngẫu nhiên (RAM) và các thiết bị DMA. Giao diện giữa bus AHB và bus APB là thông qua 1 mô-đun cầu bus. 
Giao thức bus AHB AMBA được thiết kế để thực hiện một hệ thống đa chủ (nhiều master). Không giống như hầu hết các kiến trúc bus được thiết kế cho các hệ thống dựa trên PCB, bus AMBA AHB tránh thực hiện tristate bằng cách sử dụng sơ đồ kết nối bộ ghép kênh trung tâm. Phương pháp kết nối này cung cấp hiệu suất cao hơn và công suất thấp hơn so với sử dụng bộ đệm tristate. Tất cả các bus master đều xác định địa chỉ và tín hiệu điều khiển, tín hiệu cho biết loại transaction. Một bộ phân xử trung tâm xác định master nào có địa chỉ và tín hiệu điều khiển được định tuyến đến tất cả các slave. Một mạch decoder (mạch giải mã trung tâm) chọn dữ liệu đọc thích hợp và tín hiệu xác nhận phản hồi từ slave có liên quan đến giao dịch. Hình 5 .3 mô tả sơ đồ kết nối ghép kênh như vậy cho một hệ thống có ba masters và bốn slave. Giao dịch trên bus AHB bao gồm các bước sau:
    • Bus Master có được quyền truy cập vào bus: Quá trình này bắt đầu với việc master gửi tín hiệu request đến bộ phân xử. Nếu có nhiều hơn một master đồng thời gửi tín hiệu đến bus, bộ phân xử sẽ xác định master nào trong số các master đã gửi request sẽ được cấp quyền sử dụng bus.
• Bus Master bắt đầu gửi dữ liệu: Một master được bộ phân xử cấp quyền sẽ gửi tín hiệu địa chỉ , tín hiệu điều khiển, hướng và độ rộng của các transaction. Nó cũng cho biết liệu các transaction có gửi theo burst hay không (trong trường hợp hoạt động ở chế độ burst). Khi master muốn read, data được đọc từ slave đến master. Ngược lại nếu là write thì data sẽ được gửi từ master đến slave.

Bus Slave gửi tín hiệu response để thông báo trạng thái: Slave sẽ trả về một tín hiệu để thông báo cho master biết về trạng thái của transaction hiện tại, chẳng hạn như liệu nó có thành công hay không, có trì hoãn hoặc xảy ra lỗi gì không.
 Hình 5.4 mô tả một quá trình truyền dữ liệu cơ bản của chuẩn giao tiếp AHB. Quá trình truyền (AHB) bao gồm hai pha riêng biệt: pha địa chỉ và pha dữ liệu.
 Master gửi tín hiệu địa chỉ (ADDR) và tín hiệu điều khiển khi có cạnh lên của xung clock (CLK) trong pha địa chỉ (tín hiệu được assert phải có thời gian kéo dài hơn 1 chu kì, vì nhỏ hơn 1 chu kì data có thể bị lost vì không thể bắt kịp xung lên của clock). Sau đó, slave nhận tín hiệu địa chỉ và tín hiệu điều khiển và gửi tín hiệu phản hồi tương ứng (với hoạt động đọc dữ liệu (RDATA) hoặc ghi (WDATA) và cho biết sự hoàn thành của nó với tín hiệu READY). 
     APB được tối ưu hóa cho công suất tối thiểu và độ phức tạp thấp thay vì hiệu suất. Nó được sử dụng để giao tiếp với các thiết bị ngoại vi, có băng thông thấp.
Hoạt động của APB rất đơn giản và có thể được mô tả bằng sơ đồ trạng thái với ba trạng thái. APB ở trạng thái chờ, trạng thái thiết lặp và trạng thái hoạt động trong khi truyền dữ liệu.



5.4.2 CoreConnect 
Tương tự như chuẩn AMBA, CoreConnect của IBM là một tiêu chuẩn bus được thiết kế xung quanh lõi của một vi xử lý cụ thể, PowerPC, nhưng nó cũng có thể được sử dụng cho các bộ vi xử lý khác. CoreConnect Bus và AMBA bus có nhiều tính năng chung phổ biến. Cả hai đều có hệ thống bus nhầm hỗ trợ các yêu cầu khác nhau của hệ thống chẳng hạn hiệu suất và độ phức tạp của bus. Cả hai đều có các tính năng bus tiên tiến như multiple masters, kênh đọc / ghi riêng biệt, hỗ trợ pipeline, phân chia gói dữ liệu gửi đi, gửi data theo cụm và độ rộng bus có thể mở rộng. Kiến trúc CoreConnect cung cấp ba bus cho các lõi kết nối, thư viện macro và logic tùy chỉnh:
    • bus cục bộ của vi xử lý (PLB).
    • bus ngoại vi trên chip (OPB).
    • bus thanh ghi điều khiển thiết bị (DCR).
 Hình 5.5 minh họa cách kiến trúc CoreConnect có thể được sử dụng trong hệ thống SOC được xây dựng xung quanh vi xử lí PowerPC. Các khối hiệu suất cao, băng thông cao như lõi CPU PowerPC 440, cầu bus PCI-X và PC133 / DDR133 (DDR1 với bus 133 MHz). Bộ điều khiển RAM động đồng bộ (SDRAM) được kết nối với nhau bằng PLB, trong khi OPB liên kết các thiết bị ngoại vi trên chip tốc độ dữ liệu thấp hơn. Bus DCR được nối tiếp cung cấp một cơ sở dữ liệu tốc độ tương đối thấp để truyền thông tin cấu hình và thông tin trạng thái giữa lõi CPU PowerPC 440 và các mô-đun trên chip khác.
PLB
PLB được sử dụng cho các băng thông cao, độ chính xác cao và các kết nối có độ bền thấp giữa các vi xử lý, bộ nhớ và bộ điều khiển DMA. Đây là một bus giao dịch phân chia hoàn toàn đồng bộ với các địa chỉ riêng biệt, đọc và ghi các bus dữ liệu, cho phép hai lần gửi dữ liệu đồng thời trên mỗi chu kỳ xung clock. Tất cả các masters đều có địa chỉ riêng, dữ liệu đọc, dữ liệu ghi và tín hiệu điều khiển được gọi là các tín hiệu chuyển đổi. Các bus slave cũng có địa chỉ, dữ liệu đọc và dữ liệu ghi, nhưng những bus này được chia sẻ với nhau. 
Các giao dịch liên quan đến bus địa chỉ có ba giai đoạn: request (RQ), chuyển (XFER) và xác nhận địa chỉ (ACK). Một giao dịch PLB bắt đầu khi một master lái địa chỉ của mình và chuyển tín hiệu và yêu cầu gửi data. Sau khi bộ phân xử PLB cấp quyền sở hữu bus, tín hiệu địa chỉ và các tín hiệu giao dịch được gửi đến slaves trong giai đoạn gửi dữ liệu. Hình 5 .6 minh họa hai đường dẫn địa chỉ đọc và ghi sâu cùng với các nhiệm kỳ đọc và ghi dữ liệu đồng thời. Master A và Master B đại diện cho trạng thái của từng địa chỉ của Master và chuyển giao quyền. PLB phân xử giữa các yêu cầu này và chuyển yêu cầu chính được chọn vào bus địa chỉ nô lệ PLB. Dấu vết được gắn nhãn Giai đoạn địa chỉ hiển thị trạng thái của bus địa chỉ nô lệ PLB trong mỗi đồng hồ PLB. Mỗi nhịp dữ liệu trong nhiệm kỳ dữ liệu có hai giai đoạn: chuyển giao và xác nhận. Trong giai đoạn chuyển giao, chủ điều khiển bus dữ liệu ghi để truyền ghi hoặc lấy mẫu bus dữ liệu đọc để truyền đọc. Như được hiển thị trong Hình 5.6, nhịp dữ liệu đầu tiên (hoặc duy nhất) của một lần truyền ghi trùng khớp với giai đoạn chuyển địa chỉ.
  Giao dịch phân chia Địa chỉ PLB, đọc dữ liệu và ghi bus dữ liệu được tách rời, cho phép các chu kỳ địa chỉ được chồng lấp với chu kỳ đọc hoặc ghi dữ liệu và cho các chu kỳ dữ liệu đọc được chồng lấp với chu kỳ ghi dữ liệu. Khả năng giao dịch xe buýt phân chia PLB cho phép địa chỉ và xe buýt dữ liệu có các chủ khác nhau cùng một lúc. Ngoài ra, chủ thứ hai có thể yêu cầu quyền sở hữu PLB, thông qua đường ống địa chỉ, song song với chu kỳ dữ liệu của chuyển giao xe buýt chính khác. Tình huống này được minh họa trong Hình 5 .6, với sự phụ thuộc của các tín hiệu khác nhau được chỉ định bởi các mũi tên.
  OPB
     OPB là một bus thứ cấp được thiết kế để giảm bớt các tắc nghẽn về hiệu suất hệ thống bằng cách giảm tải điện dung trên PLB [126]. Các thiết bị ngoại vi phù hợp để đính kèm với OPB bao gồm các cổng nối tiếp, cổng song song, UART, GPIO (I / O mục đích chung), bộ hẹn giờ và các thiết bị băng thông thấp khác. OPB tinh vi hơn APBA AMBA. Nó hỗ trợ nhiều chủ và nô lệ bằng cách thực hiện các bus địa chỉ và dữ liệu như một bộ ghép kênh phân tán. Kiểu cấu trúc này phù hợp với bus OPB ít dữ liệu hơn và cho phép các thiết bị ngoại vi được thêm vào thiết kế logic lõi tùy chỉnh mà không thay đổi I / O trên arbiter OPBiter hoặc các thiết bị ngoại vi hiện có. Hình 5 .7 cho thấy một phương pháp cấu trúc địa chỉ OPB và các bus dữ liệu. Cả chủ và nô lệ đều cung cấp tín hiệu điều khiển cho xe buýt đi của họ. Bằng cách yêu cầu mỗi đơn vị cung cấp tín hiệu này, bus kết hợp logic có thể được đặt một cách chiến lược trên toàn bộ chip. Như thể hiện trong,

5.5.1 Sự tham gia và sự tham gia của xe buýt
 dùng chung xảy ra ở bất cứ nơi nào hai hoặc nhiều đơn vị yêu cầu một tài nguyên được chia sẻ không thể cung cấp cả hai cùng một lúc. Khi xảy ra tranh chấp, (1) nó sẽ trì hoãn yêu cầu của mình và không hoạt động cho đến khi tài nguyên có sẵn hoặc (2) nó xếp hàng yêu cầu của nó trong bộ đệm và tiến hành cho đến khi tài nguyên có sẵn. Trường hợp (2) chỉ có thể khi mục được yêu cầu không cần thiết về mặt logic để thực hiện chương trình (ví dụ như trong tìm nạp trước bộ đệm). Việc chúng ta có cần phân tích bus như một nguồn tranh chấp hay không phụ thuộc vào băng thông tối đa (hoặc được cung cấp) của nó so với băng thông bộ nhớ. Khi sự tranh chấp và hàng đợi phát triển tại nút thắt cổ chai trong hệ thống, tài nguyên hạn chế nhất là nguồn gốc của sự tranh chấp và các phần khác của hệ thống chỉ đóng vai trò là yếu tố trì hoãn. Do đó, xe buýt phải được phân tích để tranh chấp khi chúng hạn chế hơn (có ít băng thông khả dụng hơn) so với bộ nhớ. B sử dụng thường không có bộ đệm (hàng đợi) và sự chậm trễ truy cập gây ra sự chậm trễ hệ thống ngay lập tức. Phân tích về ảnh hưởng của tắc nghẽn xe buýt phụ thuộc vào loại truy cập và bộ đệm. Nói chung có hai loại mẫu truy cập:
   1. Yêu cầu mà không cần gửi lại ngay lập tức. Yêu cầu bị từ chối trả về với phân phối đến giống như yêu cầu ban đầu. Khi một yêu cầu bị từ chối, việc xử lý vẫn tiếp tục mặc dù việc gửi lại yêu cầu bị chậm trễ. Đây là trường hợp tìm nạp trước dòng bộ đệm, hiện không cần thiết để tiếp tục thực hiện chương trình. 
   2. Yêu cầu được gửi lại ngay lập tức. Đây là một trường hợp điển hình hơn, khi nhiều bộ xử lý độc lập truy cập vào một bus chung. Một chương trình không thể tiến hành sau khi yêu cầu bị từ chối. Nó ngay lập tức được gửi lại. Bộ xử lý không hoạt động cho đến khi yêu cầu được thực hiện và phục vụ.














	NOC LÀ GÌ?
 Khi thuật ngữ SOC đã phát triển, dường như chỉ có hai chiến lược kết nối: xe buýt hoặc NOC. Vậy chính xác thì NOC là gì? Giáo sư Nurmi (trong một bài trình bày được báo cáo bởi Leibson [156]) đã tóm tắt các đặc điểm của NOC:
1. NOC không chỉ là một chiếc xe buýt dùng chung. 2. NOC cung cấp các kết nối điểm-điểm giữa bất kỳ hai máy chủ nào được gắn vào mạng bằng các công tắc thanh ngang hoặc thông qua các công tắc dựa trên nút. 3. NOC cung cấp băng thông tổng hợp cao thông qua các liên kết song song.
 4 . Trong NOC, giao tiếp tách biệt với tính toán. 5. NOC sử dụng cách tiếp cận phân lớp cho truyền thông, mặc dù có ít lớp mạng do sự phức tạp và chi phí. 6. N OC hỗ trợ đường ống và cung cấp bộ đệm dữ liệu trung gian giữa người gửi và người nhận.
Trong bối cảnh SOC khi nhà thiết kế tìm ra công nghệ xe buýt cung cấp băng thông hoặc kết nối không cần thiết, sự thay thế rõ ràng là một loại công tắc. Bất kỳ kết nối chuyển mạch được thiết kế tốt nào cũng sẽ đáp ứng rõ ràng các điểm 2, 3, 4 và 6. Điểm 5 không bị ảnh hưởng bởi các kết nối chuyển mạch ad hoc, trong đó các nút xử lý và kết nối chuyển mạch được giao thoa bởi thiết kế chuyên dụng, phổ biến. Nhưng trong SOC, việc kết hợp nhiều IP của nhà cung cấp khác nhau liên kết với nhau gần như không bao giờ xảy ra. Nhà thiết kế chọn một giao diện truyền thông chung (lớp) tách biệt với nút bộ xử lý.


NOC VỚI INTERCONNECTS SWITCH
Kết nối bus interconnection là kiến trúc chiếm ưu thế cho các kết nối trong một hệ thống SOC, Tuy nhiên nó vẫn có một số nhược điểm. Ngay cả một hệ thống bus được thiết kế tốt cũng có thể gặp phải các trường hợp tắc nghẽn khi truyền dữ liệu, làm hạn chế hiệu suất của toàn bộ hệ thống. Khi nhiều mô-đun được thêm vào bus, không chỉ gây ra hiện tượng tắc nghẽn dữ liệu mà còn làm cho mức tiêu thụ điện năng cũng tăng. Các kết nối NOC dựa trên chuyển đổi tránh nhầm tránh một số hạn chế này. Tuy nhiên, các thiết bị chuyển mạch phức tạp hơn so với bus và nó được áp dụng nhiều nhất cho các chip SoC lớn. Chắc chắn chúng ta sẽ có sự đánh đổi lớn nếu sử dụng NOC trong hệ thống SoC. Số lượng lớn các nút có thể được kết nối với độ trễ tương đối thấp nhưng với chi phí tăng theo cấp số nhân (như với các công tắc thanh ngang) hoặc chúng có thể được thực hiện với độ trễ tương đối dài hơn và với chi phí khiêm tốn hơn (như trong kết nối phân tán). Phần này trình bày một số khái niệm cơ bản và các lựa chọn thay thế trong thiết kế mạng kết nối vật lý. Mạng này bao gồm một cấu hình các công tắc để cho phép kết nối các đơn vị N. Hiệu suất thiết kế hoặc hiệu suất chi phí của mạng kết nối được xác định bởi:
1. Sự chậm trễ trong việc kết nối một đơn vị yêu cầu đến đích của nó.
 2. Băng thông giữa các đơn vị và số lượng kết nối có thể được tiến hành đồng thời. 
3. Chi phí của mạng.

Trong một mạng, các đơn vị liên lạc với nhau thông qua một liên kết hoặc một kênh, có thể là một chiều hoặc hai chiều. Liên kết có băng thông hoặc số bit trên mỗi đơn vị thời gian có thể được truyền đồng thời giữa các đơn vị (hoặc nút). Fanout của một nút là số lượng kênh hai chiều kết nối nó với các nút lân cận (Hình 5 .11). Mạng có thể là tĩnh hoặc động. Trong một mạng tĩnh, cấu trúc liên kết hoặc mối quan hệ giữa các nút trong mạng được xác định (Hình 5.12). Đường dẫn giữa hai nút không thay đổi. Trong một mạng động, các đường dẫn giữa

